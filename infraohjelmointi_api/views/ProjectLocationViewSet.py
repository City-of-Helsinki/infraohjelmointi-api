from datetime import date
from django.db.models import Prefetch
from infraohjelmointi_api.serializers.ProjectLocationSerializer import (
    ProjectLocationSerializer,
)
from infraohjelmointi_api.services import (
    ProjectLocationService,
    LocationFinancialService,
)
from infraohjelmointi_api.models.LocationFinancial import LocationFinancial
from infraohjelmointi_api.models import Project
from overrides import override
from rest_framework.response import Response
from rest_framework.decorators import action
from .BaseClassLocationViewSet import BaseClassLocationViewSet


class ProjectLocationViewSet(BaseClassLocationViewSet):
    """
    API endpoint that allows Project Locations to be viewed or edited.
    """

    serializer_class = ProjectLocationSerializer

    @override
    def get_queryset(self):
        """Default is programmer view with optimized prefetching"""
        return (
            ProjectLocationService.list_all()
            .select_related('coordinatorLocation', 'parent', 'parentClass')
            .prefetch_related(
                'coordinatorLocation__finances',
                Prefetch(
                    'finances',
                    queryset=LocationFinancial.objects.filter(forFrameView=False).order_by('year'),
                ),
                Prefetch(
                    'project_set',
                    queryset=Project.objects.filter(programmed=True)
                    .select_related('projectLocation')
                    .prefetch_related('finances'),
                ),
            )
        )

    @action(
        methods=["get"],
        detail=False,
        url_path=r"coordinator",
        name="get_coordinator_locations",
    )
    def list_for_coordinator(self, request):
        # Dynamic docstring - see BaseClassLocationViewSet._get_coordinator_list_docstring("location", "project-locations/coordinator")
        """Dynamic docstring generated by BaseClassLocationViewSet._get_coordinator_list_docstring"""
        year = int(request.query_params.get("year", date.today().year))
        forcedToFrame = self.parse_forced_to_frame_param(
            request.query_params.get("forcedToFrame", False)
        )

        frame_budgets = self.build_frame_budgets_context(year, for_frame_view=False)

        serializer = ProjectLocationSerializer(
            ProjectLocationService.list_all_for_coordinator(),
            many=True,
            context={
                "finance_year": year,
                "for_coordinator": True,
                "forcedToFrame": forcedToFrame,
                "frame_budgets": frame_budgets
            },
        )
        return Response(serializer.data)

    @action(
        methods=["patch"],
        detail=False,
        url_path=r"coordinator/(?P<location_id>[0-9a-f]{8}\-[0-9a-f]{4}\-4[0-9a-f]{3}\-[89ab][0-9a-f]{3}\-[0-9a-f]{12})",
        name="patch_coordinator_location_finances",
    )
    def patch_coordinator_location_finances(self, request, location_id):
        # Dynamic docstring - see BaseClassLocationViewSet._get_coordinator_patch_docstring("location", "project-locations", "location_id")
        """Dynamic docstring generated by BaseClassLocationViewSet._get_coordinator_patch_docstring"""
        success, result = self.validate_and_process_patch_finances(
            request=request,
            entity_id=location_id,
            entity_service=ProjectLocationService,
            financial_service=LocationFinancialService,
            financial_model=LocationFinancial,
            relation_field="locationRelation"
        )

        if not success:
            return result

        return self.create_patch_response(
            entity_id=location_id,
            start_year=result["start_year"],
            entity_service=ProjectLocationService,
            serializer_class=ProjectLocationSerializer
        )

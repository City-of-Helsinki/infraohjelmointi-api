from datetime import date
from .BaseClassLocationViewSet import BaseClassLocationViewSet
from infraohjelmointi_api.serializers import ProjectClassSerializer
from infraohjelmointi_api.models.ClassFinancial import ClassFinancial
from infraohjelmointi_api.services import ProjectClassService, ClassFinancialService
from overrides import override
from rest_framework.response import Response
from rest_framework.decorators import action


class ProjectClassViewSet(BaseClassLocationViewSet):
    """
    API endpoint that allows Project Classes to be viewed or edited.
    """

    serializer_class = ProjectClassSerializer

    @override
    def get_queryset(self):
        """Default is programmer view with user role filtering"""
        queryset = (
            ProjectClassService.list_all()
            .select_related("coordinatorClass", "coordinatorClass__parent", "coordinatorClass__parent__parent")
            .prefetch_related("coordinatorClass__finances")
        )

        # Apply user role-based filtering
        user = self.request.user
        if hasattr(user, 'groups'):
            # Check if user is project area planner (should only see 808 classes)
            if user.groups.filter(name='project_area_planners').exists():
                queryset = queryset.filter(
                    name__startswith='808'
                ) | queryset.filter(
                    name__startswith='8 08'
                )

        return queryset

    @action(
        methods=["get"],
        detail=False,
        url_path=r"coordinator",
        name="get_coordinator_classes",
    )
    def get_coordinator_classes(self, request):
        """Get coordinator classes with filtering"""
        return self.list_for_coordinator(request)

    @action(
        methods=["get"],
        detail=False,
        url_path=r"hierarchy/(?P<parent_id>[^/.]+)",
        name="get_class_hierarchy",
    )
    def get_class_hierarchy(self, request, parent_id=None):
        """
        Get class hierarchy for a given parent class.
        Returns master classes, classes, and subclasses based on the parent.
        """
        try:
            # Get the parent class
            parent_class = self.get_queryset().get(id=parent_id)

            # Get all classes for the hierarchy
            all_classes = self.get_queryset()

            # Determine what type of parent this is and return appropriate children
            if parent_class.parent is None:  # Master class
                classes = all_classes.filter(parent=parent_id)
                subclasses = all_classes.filter(parent__in=classes.values_list('id', flat=True))
            elif parent_class.parent and all_classes.filter(parent=parent_class.parent).exists():  # Class
                subclasses = all_classes.filter(parent=parent_id)
                classes = all_classes.filter(id=parent_id)
            else:  # Subclass
                subclasses = all_classes.filter(id=parent_id)
                classes = all_classes.filter(id=parent_class.parent)

            # Serialize the results
            serializer = self.get_serializer_class()
            return Response({
                'masterClasses': serializer([parent_class] if parent_class.parent is None else [], many=True).data,
                'classes': serializer(classes, many=True).data,
                'subClasses': serializer(subclasses, many=True).data,
            })
        except Exception as e:
            return Response({'error': str(e)}, status=400)
    def list_for_coordinator(self, request):
        # Dynamic docstring - see BaseClassLocationViewSet._get_coordinator_list_docstring("class", "project-classes")
        """Dynamic docstring generated by BaseClassLocationViewSet._get_coordinator_list_docstring"""

        year = int(request.query_params.get("year", date.today().year))
        forcedToFrame = self.parse_forced_to_frame_param(
            request.query_params.get("forcedToFrame", False)
        )

        frame_budgets = self.build_frame_budgets_context(year, for_frame_view=False)

        serializer = ProjectClassSerializer(
            ProjectClassService.list_all_for_coordinator()
            .select_related(
                "parent",
                "relatedTo",
                "relatedLocation",
                "coordinatorClass",
                "coordinatorClass__parent",
                "coordinatorClass__parent__parent"
            ),
            many=True,
            context={
                "finance_year": year,
                "for_coordinator": True,
                "forcedToFrame": forcedToFrame,
                "frame_budgets": frame_budgets
            },
        )

        return Response(serializer.data)

    @action(
        methods=["patch"],
        detail=False,
        url_path=r"coordinator/(?P<class_id>[0-9a-f]{8}\-[0-9a-f]{4}\-4[0-9a-f]{3}\-[89ab][0-9a-f]{3}\-[0-9a-f]{12})",
        name="patch_coordinator_class_finances",
    )
    def patch_coordinator_class_finances(self, request, class_id):
        # Dynamic docstring - see BaseClassLocationViewSet._get_coordinator_patch_docstring("class", "project-classes", "class_id")
        """Dynamic docstring generated by BaseClassLocationViewSet._get_coordinator_patch_docstring"""
        success, result = self.validate_and_process_patch_finances(
            request=request,
            entity_id=class_id,
            entity_service=ProjectClassService,
            financial_service=ClassFinancialService,
            financial_model=ClassFinancial,
            relation_field="classRelation"
        )

        if not success:
            return result

        return self.create_patch_response(
            entity_id=class_id,
            start_year=result["start_year"],
            entity_service=ProjectClassService,
            serializer_class=ProjectClassSerializer
        )

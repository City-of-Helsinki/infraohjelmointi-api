from datetime import date
from .BaseClassLocationViewSet import BaseClassLocationViewSet
from infraohjelmointi_api.serializers import ProjectClassSerializer
from infraohjelmointi_api.models.ClassFinancial import ClassFinancial
from infraohjelmointi_api.services import ProjectClassService, ClassFinancialService
from overrides import override
from rest_framework.response import Response
from rest_framework.decorators import action


class ProjectClassViewSet(BaseClassLocationViewSet):
    """
    API endpoint that allows Project Classes to be viewed or edited.
    """

    serializer_class = ProjectClassSerializer

    @override
    def get_queryset(self):
        """Default is programmer view"""
        return (
            ProjectClassService.list_all()
            .select_related("coordinatorClass")
            .prefetch_related("coordinatorClass__finances")
        )

    @action(
        methods=["get"],
        detail=False,
        url_path=r"coordinator",
        name="get_coordinator_classes",
    )
    def list_for_coordinator(self, request):
        # Dynamic docstring - see BaseClassLocationViewSet._get_coordinator_list_docstring("class", "project-classes")
        """Dynamic docstring generated by BaseClassLocationViewSet._get_coordinator_list_docstring"""

        year = int(request.query_params.get("year", date.today().year))
        forcedToFrame = self.parse_forced_to_frame_param(
            request.query_params.get("forcedToFrame", False)
        )

        frame_budgets = self.build_frame_budgets_context(year, for_frame_view=False)

        serializer = ProjectClassSerializer(
            ProjectClassService.list_all_for_coordinator()
            .select_related(
                "parent",
                "relatedTo",
                "relatedLocation",
                "coordinatorClass"
            ),
            many=True,
            context={
                "finance_year": year,
                "for_coordinator": True,
                "forcedToFrame": forcedToFrame,
                "frame_budgets": frame_budgets
            },
        )

        return Response(serializer.data)

    @action(
        methods=["patch"],
        detail=False,
        url_path=r"coordinator/(?P<class_id>[0-9a-f]{8}\-[0-9a-f]{4}\-4[0-9a-f]{3}\-[89ab][0-9a-f]{3}\-[0-9a-f]{12})",
        name="patch_coordinator_class_finances",
    )
    def patch_coordinator_class_finances(self, request, class_id):
        # Dynamic docstring - see BaseClassLocationViewSet._get_coordinator_patch_docstring("class", "project-classes", "class_id")
        """Dynamic docstring generated by BaseClassLocationViewSet._get_coordinator_patch_docstring"""
        success, result = self.validate_and_process_patch_finances(
            request=request,
            entity_id=class_id,
            entity_service=ProjectClassService,
            financial_service=ClassFinancialService,
            financial_model=ClassFinancial,
            relation_field="classRelation"
        )

        if not success:
            return result

        return self.create_patch_response(
            entity_id=class_id,
            start_year=result["start_year"],
            entity_service=ProjectClassService,
            serializer_class=ProjectClassSerializer
        )
